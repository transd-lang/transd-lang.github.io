<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8">
<title>TransD Programming Language Reference Manual</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta http-equiv="content-language" content="en-US">
<meta name="language" content="English">
<meta name="description" content="Reference manual for Transd programming language">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link href="../../css/codehighlight.css" rel="stylesheet" type="text/css" />
<link href="../../css/tsd.css" rel="stylesheet" type="text/css" />
<link href="refman.css" rel="stylesheet" type="text/css" />
<style>
hr {
  border-top: 1px solid #eee;
  width: 50%;
  margin: 40px auto 20px auto;
  color: #bbb;
}
body { font: 1em "Trebuchet MS", Arial, Sans-Serif; color: #444; }
	h1 { font: bold 2.2em serif; color: #707070;}
	h1 a { text-decoration: none; }
	h2 { font: normal 1.8em sans-serif; color: #505050; margin: 1.5em 1em 1em auto; }
	h3 { font: bold 1.6em serif; color: #4040a0; margin: 1.5em 0 .5em; }
	h4 { font: bold 1.3em sans-serif; color: #707070; margin: 1.2em 0 1.3em; }
	h5 { font: normal 1.2em sans-serif; color: #404040; margin: 1.2em 0.5em 1.3em; }
	h6 { font: bold 1.2em sans-serif; color: #4040a0; margin: 0 0 0.5em 0; }	
	p  { margin: 0 0 1em 0; line-height: 1.5em; }
code { text-align: left; font: 1.0em Consolata, Monospace, "Courier New"; padding: 0px;
		background-color: #e8e8e8; line-height: 1.5em; }
pre { font-size: 1.0em; color: #555; padding: 10px; margin: -5px auto 15px auto;background-color: #e8e8e8; line-height: 1.5em;}

</style>
</head>
<body>
<div class="wrap">
<hr width="100%" style="margin:5px 0 35px 0;">
<h1 id="transd-reference-manual" style="margin-bottom: 0;
font-size: 3em; font-weight: normal; color: #005b56; font-family: serif;">Transd Reference Manual</h1>
<p>(Work in progress)</p>
<hr width="100%" height="1px" style="border-top: 1px solid #bbb;margin:0 0 100px 0;" color="#aaa">

<h1 id="transd-programming-language">Transd programming language</h1>

<p>Transd is a general purpose programming language, statically typed, multi-paradigm, with meta-compilation execution model. Its defining features are its novel execution model, which doesn't require the compilation to machine code, but at the same time is considerably faster than traditional interpretation technics, and, secondly, the ultimate compactness of implementation: in one executable file or in a two-file source code library you get a modern language with a number of powerful features.</p>

<p>Transd is based on the idea of <strong>modular programming</strong> - "a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality". Modules are the top-level building blocks in Transd programs.</p>

<p>Transd syntax is based on the fully parenthesized prefix notation and thus naturally supports the <strong>functional programming</strong> style - "a declarative programming paradigm in which function definitions are trees of expressions that map values to other values, rather than a sequence of imperative statements which update the running state of the program".</p>

<p>Transd has classes and facilitates the <strong>object-oriented programming</strong> style with a powerful <em>data importing</em> feature, which allows the definition of program objects outside of the program in text format, and then importing them into the program. If the program's logic is expressed via objects (as it normally is in OOP), then a large part of the program's behaviour can be defined in text files and loaded into the program at runtime.</p>

<p>Transd has built-in data types for working with structured text data (table, dataset, database) and includes elements of <strong>declarative programming</strong> in the form of built-in data query language for performing simple database-like queries on medium-sized datasets.
<br><br></p>

<h1 id="lexical-conventions">Lexical conventions</h1>

<p>Transd source files are encoded in UTF-8. Upper and lower character cases are distinguished.</p>

<p>Source files can contain comments, which can be marked by one of two ways: </p>

<ol>
<li>Character sequence <code>//</code> (slash, slash) anywhere on a line marks the start of a comment which extends to the end of the line.</li>
<li>Character sequence <code>/*</code> (slash, asterisk) marks the start of a comment which extends to the nearest character sequence <code>*/</code> (asterisk, slash). All characters between two slashes included are replaced with one whitespace character. (For example, a sequence <code>A/*B, B*/A</code> will be treated as <code>A A</code>.</li>
</ol>

<p>Identifiers in Transd can be any string of letters, digits, and underscores, not beginning with a digit. Letter is any symbol considered alphabetic under the current locale.</p>

<p>The formal syntax of language parts in this manual is described using a variant of Backus-Naur Form (BNF) specification.</p>

<p>A BNF specification is a set of derivation rules, written as</p>

<pre><code> symbol := __expression__
</code></pre>

<p>where <code>symbol</code> is a non-terminal, and the <code>__expression__</code> consists of one or more sequences of symbols. The ":=" means that the symbol on the left must be replaced with the expression on the right. The vertical bar <code>"|"</code> separates different variants of the item. Terms in square brackets are optional; parentheses group terms into one item; asterisk means that an item can occur zero or more times; capitalized words denote terminal symbols (that is basic symbols, not parsable into smaller parts.)</p>

<p>Example:</p>

<pre><code>    module := MODULE_NAME ": {" [member] ("," member)* "}"
    member := (field | method)
    field := NAME ":" (type_constructor | value_initializer)
</code></pre>

<h2 id="source-files">Source files</h2>

<p>Transd program are defined in one or more source files. Source files should be in UTF-8 encoding. The program code in a source file should be placed after the Transd code marker:</p>

<p><code>#lang transd</code></p>

<p><br></p>

<hr />

<p><br></p>

<h1 id="modules">Modules</h1>

<p>Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality.</p>

<p>When creating a modular system, instead of creating a monolithic application, several smaller modules are written separately so when they are composed together, they construct the executable application program. </p>

<p>A module in Transd is a logical part of the program. The program is partitioned into modules as it sees fit by the programmer. A Transd program can be wholly contained in one module, or its functionality can be distributed between several modules.</p>

<p>Programmatically, a module is an arbitrary block of grouped together data variables and functions, which are collectively called <em>module members</em>. All module members within one module are visible and accessible to each other. </p>

<p>One source file can contain several modules. Also, a definition of a large module can be contained in several source files. Each module in the program should have a unique name.</p>

<p>The grammar of a module definition:</p>

<pre><code>    module := MODULE_NAME ": {" [member] ("," member)* "}"
    member := NAME ":" declarator
</code></pre>

<p>Example:</p>

<div class="codehilite"><pre><span></span><code><span class="nv">MainModule</span> <span class="o">:</span> <span class="p">{</span>
  <span class="nv">s</span> <span class="o">:</span> <span class="s">&quot;Hello, world!&quot;</span><span class="o">,</span>
  <span class="nv">_start</span> <span class="o">:</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">textout</span> <span class="nv">s</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>

<h1 id="forms">Forms</h1>

<p>In Transd, as in other languages, the computation is done by evaluating expressions. An expression is a piece of code which can be evaluated as a single whole and whose data value can be obtained. Expressions consist of expression members called <em>constituents</em>. </p>

<p>Transd's syntax for expressions is based on the fully parenthesized prefix notation, in which expressions are enclosed in parentheses and have a similar structure resembling a function call: the first constituent always names the operation performed by the expression, and the remaining constituents are parameters to that operation. Such parenthesized  construction in Transd is called <em>form</em>. The first constituent of a form is called the form's <em>subject</em>. Forms can contain other forms as constituents.</p>

<p>Examples of forms:</p>

<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="nb">== </span><span class="p">(</span><span class="nb">+ </span><span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="nf">computeDistance</span> <span class="nv">Point</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="nv">Point</span><span class="p">(</span><span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="nf">textout</span> <span class="s">&quot;five plus three equals&quot;</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">5</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nf">sqrt</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">pow</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x1</span> <span class="nv">x2</span><span class="p">)</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">(</span><span class="nf">pow</span> <span class="p">(</span><span class="nb">- </span><span class="nv">y1</span> <span class="nv">y2</span><span class="p">)</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">)</span>
</code></pre></div>

<p><br></p>

<hr />

<p><br></p>

<h1 id="variables">Variables</h1>

<p>A variable in Transd is a named reference to an object in memory. When a variable is declared, it receives a type, and it can only refer to values of that type.</p>

<p>Variables can be declared in several ways, which determine their scope and lifetime:</p>

<ul>
<li>Module members (<em>fields</em>);</li>
<li>Function's <em>local</em> variables;</li>
<li><em>Scoped</em> variables.</li>
</ul>

<h3 id="module-fields">Module fields</h3>

<p>Module fields are declared within a module as part of module definition.
The syntax for a module field declaration is as follows:</p>

<pre><code>    field := NAME ":" (type_constructor | value_initializer)
</code></pre>

<p>Example:</p>

<div class="codehilite"><pre><span></span><code><span class="nv">Module1</span><span class="o">:</span> <span class="p">{</span>
  <span class="nv">s</span><span class="o">:</span>  <span class="nv">String</span><span class="p">()</span><span class="o">,</span>
  <span class="nv">s1</span><span class="o">:</span> <span class="nv">String</span><span class="p">(</span><span class="s">&quot;some string&quot;</span><span class="p">)</span><span class="o">,</span>
  <span class="nv">v</span><span class="o">:</span>  <span class="nb">Vector&lt;Int&gt;</span><span class="p">(</span> <span class="mi">10</span> <span class="p">)</span><span class="o">,</span>
  <span class="nv">v1</span><span class="o">:</span> <span class="nb">Vector&lt;Int&gt;</span><span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">]</span> <span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>In the example above, the <code>s</code> and <code>s1</code> fields are declared as Strings and <code>s1</code> is initialized with "some string" value. The <code>v</code> and <code>v1</code> fields are declared as Vectors of integers. <code>v</code> is initialized with a special type constructor which fills it with 10 integers having the default (zero) value. <code>v1</code> vector is filled with 3 integers, which have values <code>1</code>, <code>2</code> and <code>3</code>.</p>

<p>The above example uses the explicit type constructors for all four fields. When a type allows initializing with a literal value, and the field type can be inferred from the literal, then a short form of initialization can be used (called <em>value initialization</em>):</p>

<p>Example:</p>

<div class="codehilite"><pre><span></span><code><span class="nv">Module1</span><span class="o">:</span> <span class="p">{</span>
  <span class="nv">s1</span><span class="o">:</span> <span class="s">&quot;some string&quot;</span><span class="o">,</span> 
  <span class="nv">v1</span><span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div>

<p><code>s1</code> here becomes a String with "some string" value. <code>v</code> - becomes a Vector<Int> filled with '1', '2', '3' integers.</p>

<p>Module fields by default are only visible within the module in which the field is defined. For allowing access to a field from other modules, that field must be declared as public.</p>

<p>Fields are created at the program's start and continue their existence until the end of the program.</p>

<h3 id="local-variables">Local variables</h3>

<p>Functions' local variables are declared at the beginning of function declaration. They are visible only within that function and remain valid until the return from the function.</p>

<p>Local variables are introduced with the <code>locals:</code> keyword just after the function signature:</p>

<div class="codehilite"><pre><span></span><code><span class="nv">func</span><span class="o">:</span> <span class="p">(</span><span class="nf">λ</span> <span class="nv">par</span> <span class="nv">Int</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nv">Bool</span><span class="p">()</span> 
         <span class="nv">locals</span><span class="o">:</span> <span class="nv">b</span> <span class="nv">Bool</span><span class="p">(</span><span class="nf">True</span><span class="p">)</span>
         <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="o">&lt;</span> <span class="nv">par</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">b</span> <span class="nv">false</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">ret</span> <span class="nv">b</span><span class="p">))</span><span class="o">,</span>
<span class="nv">func1</span><span class="o">:</span> <span class="p">(</span><span class="nf">λ</span> <span class="nv">a</span> <span class="nv">Int</span><span class="p">()</span> <span class="nv">b</span> <span class="nv">Int</span><span class="p">()</span>
         <span class="nv">locals</span><span class="o">:</span> <span class="nv">c</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="mi">10</span><span class="p">)</span> <span class="nv">d</span> <span class="p">(</span><span class="nb">* </span><span class="nv">b</span> <span class="mi">5</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">ret</span> <span class="p">(</span><span class="nb">* </span><span class="nv">c</span> <span class="nv">d</span><span class="p">)))</span><span class="o">,</span>
<span class="nv">func2</span><span class="o">:</span> <span class="p">(</span><span class="nf">λ</span> <span class="nv">locals</span><span class="o">:</span> <span class="nv">s1</span> <span class="s">&quot;Hello, &quot;</span> <span class="nv">s2</span> <span class="s">&quot;world!&quot;</span>
         <span class="p">(</span><span class="nf">ret</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">s1</span> <span class="nv">s2</span><span class="p">)))</span><span class="o">,</span>
<span class="nv">func4</span><span class="o">:</span> <span class="p">(</span><span class="nf">λ</span> <span class="nv">v</span> <span class="nb">Vector&lt;Int&gt;</span><span class="p">()</span> <span class="nv">locals</span><span class="o">:</span> <span class="nv">v1</span> <span class="p">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">]</span>
         <span class="p">(</span><span class="nf">ret</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">v</span> <span class="nv">v1</span><span class="p">)))</span>
</code></pre></div>

<p>The grammar for declaration of local variables is as follows:</p>

<pre><code>    local_var := NAME " " (type_constructor | value_initializer | expression)
</code></pre>

<p>The rules for initialization of local variables are the same as for module fields, and additionally include the initialization with an expression: in the example above, the locals <code>c</code> and <code>d</code> in <code>func1</code> are initialized with expressions.</p>

<h3 id="scoped-variables">Scoped variables</h3>

<p>The <code>(with ...)</code> scoping operator allows creating of variables whose visibility and lifetime are limited to that scoping operator's body. Scoped variables are declared and remain valid within the scoping operator block.</p>

<p>Initialization rules for scoped variables are the same as for function's local variables.</p>

<div class="codehilite"><pre><span></span><code><span class="nv">MainModule</span><span class="o">:</span> <span class="p">{</span>
  <span class="nv">a</span><span class="o">:</span> <span class="mi">5</span><span class="o">,</span>
  <span class="nv">_start</span><span class="o">:</span> <span class="p">(</span><span class="nf">λ</span>
    <span class="p">(</span><span class="nf">lout</span> <span class="s">&quot;a is &quot;</span> <span class="nv">a</span><span class="p">)</span>        <span class="c1">//&lt;= a is 5</span>
    <span class="p">(</span><span class="k">with </span><span class="nv">a</span> <span class="mi">25</span> <span class="nv">b</span> <span class="mi">40</span>
        <span class="p">(</span><span class="nf">lout</span> <span class="nv">a</span> <span class="s">&quot; &quot;</span> <span class="nv">b</span><span class="p">)</span>      <span class="c1">//&lt;= 25 40</span>
    <span class="p">)</span>
    <span class="p">(</span><span class="nf">lout</span> <span class="s">&quot;a is &quot;</span> <span class="nv">a</span><span class="p">)</span>        <span class="c1">//&lt;= a is 5</span>
    <span class="p">(</span><span class="nf">lout</span> <span class="s">&quot;b is &quot;</span> <span class="nv">b</span><span class="p">)</span>        <span class="c1">//&lt;= ERROR: undefined variable</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p><br></p>

<hr />

<p><br></p>

<h1 id="functions">Functions</h1>

<p>Functions in Transd are named expressions, which are executed via their names:</p>

<div class="codehilite"><pre><span></span><code><span class="nv">say-hi</span><span class="o">:</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">textout</span> <span class="s">&quot;Hi!&quot;</span><span class="p">))</span><span class="o">,</span>

<span class="nv">_start</span><span class="o">:</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">say-hi</span><span class="p">))</span> <span class="c1">// &lt;= Hi!</span>
</code></pre></div>

<p>A definition of a function starts with the <code>lambda</code> keyword. There is a shorter
synonim for <code>lambda</code> keyword - one-symbol keyword <code>λ</code> (Unicode symbol 955 (0x3BB)). These
two names are exact equivalents and can be used interchangeably.</p>

<p>Functions can have parameters which are listed along with their types just after <code>lambda</code> keyword:</p>

<div class="codehilite"><pre><span></span><code><span class="nv">say</span><span class="o">:</span> <span class="p">(</span><span class="k">lambda </span><span class="nv">phrase</span> <span class="nv">String</span><span class="p">()</span> <span class="p">(</span><span class="nf">textout</span> <span class="nv">phrase</span><span class="p">))</span><span class="o">,</span>

<span class="nv">add</span><span class="o">:</span> <span class="p">(</span><span class="nf">λ</span> <span class="nv">a</span> <span class="nv">Int</span><span class="p">()</span> <span class="nv">b</span> <span class="nv">Int</span><span class="p">()</span> <span class="p">(</span><span class="nf">textout</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span><span class="o">,</span>

<span class="nv">_start</span><span class="o">:</span> <span class="p">(</span><span class="nf">λ</span> <span class="p">(</span><span class="nf">say</span> <span class="s">&quot;Hi!&quot;</span><span class="p">)</span> <span class="c1">// &lt;= Hi!</span>
           <span class="p">(</span><span class="nf">add</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1">// &lt;= 2</span>
</code></pre></div>

<h3 id="bound-and-unbound-functions">Bound and unbound functions</h3>

<p>As in other languages, in Transd one distinguishes between a call of an <em>unbound routine</em> and a call of a <em>bound object's method</em>. For example, in Python these two cases differ syntactically as follows:</p>

<div class="codehilite"><pre><span></span><code><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Hi!&quot;</span>
<span class="nb">print</span><span class="p">(</span> <span class="n">s</span> <span class="p">)</span>  <span class="c1"># call of an unbound routine &#39;print()&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span> <span class="s2">&quot;H&quot;</span> <span class="p">)</span> <span class="c1"># call of a bound object&#39;s method &#39;startswith()&#39;</span>
</code></pre></div>

<p>Transd's equivalent looks as follows:</p>

<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nb">= </span><span class="nv">s</span> <span class="s">&quot;Hi!&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">lout</span> <span class="nv">s</span><span class="p">)</span>
<span class="p">(</span><span class="nb">= </span><span class="nv">b</span> <span class="p">(</span><span class="nf">startswith</span> <span class="nv">s</span> <span class="s">&quot;H&quot;</span><span class="p">))</span>
</code></pre></div>

<p>When a method of object is called - whether an object of a built-in type such as String or Vector, or an object of a user-defined type - the first parameter of such call always is the reference to the object whose method is called. This first parameter in object's method calls is called the <em>subject</em> of the call.</p>

<p><br></p>

<hr />

<p><br></p>

<h1 id="classes">Classes</h1>

<p><em>Classes</em> are templates for creating objects. A template is a list of data variables, which represent a description (or a state) of some object, for example, a database record storing information about an employee:</p>

<div class="codehilite"><pre><span></span><code><span class="nv">class</span> <span class="nv">Employee</span> <span class="o">:</span> <span class="p">{</span>
  <span class="nv">id</span><span class="o">:</span> <span class="nv">Int</span><span class="p">()</span><span class="o">,</span>
  <span class="nv">name</span><span class="o">:</span> <span class="nv">String</span><span class="p">()</span><span class="o">,</span>
  <span class="nv">department</span><span class="o">:</span> <span class="nv">String</span><span class="p">()</span><span class="o">,</span>
  <span class="nv">salary</span><span class="o">:</span> <span class="nv">Int</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>

<p>Along with the list of data variables classes usually contain a list of functions which know how to operate on that data. For example, a class representing a point on a geometrical plane might have a function for computing the distance to some other point:</p>

<div class="codehilite"><pre><span></span><code><span class="nv">class</span> <span class="nv">Point</span> <span class="o">:</span> <span class="p">{</span>
  <span class="nv">x</span><span class="o">:</span> <span class="nv">Double</span><span class="p">()</span><span class="o">,</span>
  <span class="nv">y</span><span class="o">:</span> <span class="nv">Double</span><span class="p">()</span><span class="o">,</span>
  <span class="nv">distance</span><span class="o">:</span> <span class="p">(</span><span class="nf">λ</span> <span class="nv">pt</span> <span class="nv">Point</span><span class="p">()</span>
               <span class="p">(</span><span class="nf">sqrt</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">pow</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="nv">pt</span><span class="o">.</span><span class="nv">x</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">pow</span> <span class="p">(</span><span class="nb">- </span><span class="nv">y</span> <span class="nv">pt</span><span class="o">.</span><span class="nv">y</span><span class="p">)</span> <span class="mi">2</span><span class="p">))))</span>
<span class="p">}</span>
</code></pre></div>

<p>As one can see, classes have the same syntax as modules: they both are lists of functions and variables. The difference between modules and classes is that modules exist strictly in single number: you cannot have a copy of a module. Whereas you can have as many different copies of an object of some class as you want. This is why classes are called templates. When you create a copy of a template, it is said that you <em>instantiate</em> the class, that is create an instance object of that class. </p>

<p>All instance objects of a class are independent from each other: when you change the values of data variables of some objects, this doesn't affect variables of other objects.</p>

<p>Classes, in fact, are types of objects, and are similar to built-in types such as <code>String</code> or <code>Vector</code>. You instantiate a class by declaring a variable of that class in the same way as you declare variables of built-in types:</p>

<div class="codehilite"><pre><span></span><code><span class="nv">i</span><span class="o">:</span> <span class="nv">Int</span><span class="p">()</span><span class="o">,</span>
<span class="nv">str</span><span class="o">:</span> <span class="nv">String</span><span class="p">()</span><span class="o">,</span>
<span class="nv">pt</span><span class="o">:</span> <span class="nv">Point</span><span class="p">()</span><span class="o">,</span>
<span class="nv">record</span><span class="o">:</span> <span class="nv">Employee</span><span class="p">()</span>
</code></pre></div>

<h2 id="initialization-of-class-objects">Initialization of class objects</h2>

<p>Classes can have an <code>init</code> method, which is automatically called when a class instance object is created. This method can receive arguments that can be used for setting the values of the object's fields.</p>

<div class="codehilite"><pre><span></span><code><span class="nv">class</span> <span class="nv">Point</span> <span class="o">:</span> <span class="p">{</span>
  <span class="nv">x</span><span class="o">:</span> <span class="nv">Double</span><span class="p">()</span><span class="o">,</span>
  <span class="nv">y</span><span class="o">:</span> <span class="nv">Double</span><span class="p">()</span><span class="o">,</span>
  <span class="nv">init</span><span class="o">:</span> <span class="p">(</span><span class="nf">λ</span> <span class="nv">x_</span> <span class="nv">Double</span><span class="p">()</span> <span class="nv">y_</span> <span class="nv">Double</span><span class="p">()</span> <span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="nv">x_</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">y</span> <span class="nv">y_</span><span class="p">))</span>
<span class="p">}</span>

<span class="nv">pt</span><span class="o">:</span> <span class="nv">Point</span><span class="p">(</span> <span class="mf">2.71</span> <span class="mf">3.14</span> <span class="p">)</span>
</code></pre></div>

<p><br></p>

<hr />

<p><br></p>

<h1 id="type-system">Type system</h1>

<h2 id="overview-of-transd-type-system">Overview of Transd type system</h2>

<p>Transd is strongly typed and its type system offers a variety of types to choose from for a particular programming task. Each type in Transd iѕ either <em>basic</em> or <em>compound</em>, and either <em>simple</em> or <em>container</em>. Within these categories Transd types are organized as follows:</p>

<pre><code>                     Types
                    /     \
               Basic       Compound
              /     \       /      \
        Simple  Containers Simple  Containers
</code></pre>

<p><strong>Basic types</strong> are: <code>Bool</code>, <code>Byte</code>, <code>Char</code>, <code>Int</code>, <code>Long</code>, <code>ULong</code>, <code>BigLong</code>, <code>Double</code>, <code>String</code>, <code>ByteArray</code>.</p>

<p>Among basic types, <code>String</code> and <code>ByteArray</code> are containers, others - are simple types.</p>

<p>Compound types take an additional type parameter for their instantiation. For example, a vector of integers is declared as <code>Vector&lt;Int&gt;</code>. Such vector can only contain <code>Int</code>s, that is the "Int" type parameter becomes a part of the definition of the whole type. This is why such types are called "compound". Compound types are also refered to as generic types, or <em>generics</em>.</p>

<p><strong>Compound types</strong> are: <code>Position</code>, <code>Tuple</code>, <code>Vector</code>, <code>Index</code>, <code>HashIndex</code>, <code>Set</code>, <code>HashSet</code>.</p>

<p><code>Position</code> is a simple type, all other compound types are containers.</p>

<h2 id="type-traits">Type traits</h2>

<p>Each type in Transd has a set of properies associated with it. These properties are called <em>type traits</em>. Type traits are used for organizing types into a hierarchy and grouping together similar types. Such grouping makes possible polymorphic use of types.</p>

<p>For example, types <code>Double</code> and <code>Int</code> both have the <code>:Number</code> property. If some function can accept both <code>Double</code> and <code>Int</code> as a parameter, then instead of writing two overloaded versions of the function, it's possible to use the <code>:Number</code> type property as the parameter type.</p>

<p>For example, a function receiving a number and returning the integral part of that number can be defined as follows:</p>

<pre><code>intgr: (λ n :Number() (ret (to-Int n))),
</code></pre>

<p>This function will accept all numeric types (except <code>BigLong</code>), and reject all other types. Example:</p>

<div class="codehilite"><pre><span></span><code><span class="o">#</span><span class="nv">lang</span> <span class="nv">transd</span>

<span class="nv">MainModule</span><span class="o">:</span> <span class="p">{</span>
<span class="nv">i</span><span class="o">:</span> <span class="nv">Int</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">,</span>
<span class="nv">d</span><span class="o">:</span> <span class="nv">Double</span><span class="p">(</span><span class="mf">5.5</span><span class="p">)</span><span class="o">,</span>
<span class="nv">s</span><span class="o">:</span> <span class="nv">String</span><span class="p">(</span><span class="s">&quot;5&quot;</span><span class="p">)</span><span class="o">,</span>

<span class="nv">intgr</span><span class="o">:</span> <span class="p">(</span><span class="nf">λ</span> <span class="nv">n</span> <span class="o">:</span><span class="nv">Number</span><span class="p">()</span> <span class="p">(</span><span class="nf">ret</span> <span class="p">(</span><span class="nf">to-Int</span> <span class="nv">n</span><span class="p">)))</span><span class="o">,</span>

<span class="nv">_start</span><span class="o">:</span> <span class="p">(</span><span class="nf">λ</span> <span class="p">(</span><span class="nf">lout</span> <span class="p">(</span><span class="nf">intgr</span> <span class="nv">i</span><span class="p">))</span> <span class="c1">// =&gt; 5</span>
           <span class="p">(</span><span class="nf">lout</span> <span class="p">(</span><span class="nf">intgr</span> <span class="nv">d</span><span class="p">))</span> <span class="c1">// =&gt; 5</span>
           <span class="p">(</span><span class="nf">lout</span> <span class="p">(</span><span class="nf">intgr</span> <span class="nv">s</span><span class="p">))</span> <span class="c1">// compilation error!</span>
<span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="built-in-types">Built-in types</h2>

<h3 id="null">Null</h3>

<p><code>Null</code> - is a special kind of type, which no object can have except of the special “null object”. This object may be used as a placeholder indicating absence of useful value, as the return type of functions that don't return any objects, for error signalling, etc.</p>

<h3 id="bool">Bool</h3>

<p><code>Bool</code> - the Bool type is used for storing logical truth values. The objects of this type can only have two values that are represented by keywords <code>true</code> and <code>false</code>. </p>

<p>Other types are implicitly convertible to Bool type. The simple types with value <code>0</code> and containers with zero length (empty) are converted to <code>false</code>, all other values are converted to <code>true</code>.</p>

<h3 id="byte">Byte</h3>

<p><code>Byte</code> - 8-bit unsigned integer.</p>

<p><strong>Values range:</strong> 0 - 255</p>

<p><strong>Type constructor:</strong></p>

<p><code>Byte( :Integer )</code></p>

<p>This constructor accepts any integer as an initialization value, performing the automatic casting if needed.</p>

<h3 id="char">Char</h3>

<p><code>Char</code> - a type that represents a Unicode character: a Unicode code point encoded in UTF-16/32.</p>

<p><code>Char</code> is the only Transd type that has a platform-dependent size. </p>

<p>On Linux, <code>Char</code> is 4-byte wide and uses UTF-32 encoding. On Windows, <code>Char</code> is 2-byte wide and uses UTF-16LE encoding.
<br></p>

<h3 id="integral-numeric-types">Integral numeric types</h3>

<p>Integral numeric types represent integer numbers. Transd has the following integral numeric types: <code>Byte</code>, <code>Int</code>, <code>Long</code>, <code>ULong</code>.</p>

<pre><code>Type       Values range                      Size         Signed
-------------------------------------------------------------------

Byte       0 to 255                          1 byte       unsigned

Int        -2,147,483,648 to                 4 bytes      signed
           2,147,483,647

Long       -9,223,372,036,854,775,808 to     8 bytes      signed
           9,223,372,036,854,775,807

ULong      0 to 18,446,744,073,709,551,615   8 bytes      unsigned
</code></pre>

<h3 id="double">Double</h3>

<p><code>Double</code> - is double precision 64-bit IEEE 754 floating point type.</p>

<h3 id="biglong">BigLong</h3>

<p><code>BigLong</code> is an arbitrary precision signed integer type. Its range doesn't have any predefined limits and depends only on the size of computer's memory.</p>

<h2 id="streams">Streams</h2>

<p>A stream is an object that uses a generalized input/output (I/O) interface to write and read data to and from various sources and destinations. All stream classes are descendants of an abstract <code>Stream</code> class which defines this generalized IO interface.</p>

<p>Transd defines five stream classes:</p>

<ul>
<li><code>StringStream</code> - generalized text I/O;</li>
<li><code>ByteStream</code> - generalized raw bytes I/O;</li>
<li><code>FileStream</code> - file I/O;</li>
<li><code>StdIn</code> - standard input stream;</li>
<li><code>StdOut</code> - standard output stream.</li>
</ul>

<p>Streams are used for reading/writing files, outputting text to the screen, for buffered I/O, etc.</p>

<hr />

<h3 id="stringstream">StringStream</h3>

<p><code>StringStream</code> is a class that enables using a string as a source or destination of
input-output operations.</p>

<h4 id="stringstream-constructor">StringStream constructor</h4>

<div class="codehilite"><pre><span></span><code><span class="nv">StringStream</span><span class="p">()</span>
</code></pre></div>

<p>StringStream's constructor doesn't have parameters.</p>

<p><strong>Example:</strong></p>

<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">with </span><span class="nv">ss</span> <span class="nv">StringStream</span><span class="p">()</span> 
    <span class="p">(</span><span class="nf">textout</span> <span class="nv">to</span><span class="o">:</span> <span class="nv">ss</span> <span class="s">&quot;abc&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">textout</span> <span class="p">(</span><span class="nf">str</span> <span class="nv">ss</span><span class="p">)))</span> <span class="c1">// &lt;= abc</span>
</code></pre></div>

<h4 id="stringstream-methods">StringStream methods</h4>

<hr />

<h3 id="bytestream">ByteStream</h3>

<p><code>ByteStream</code> is a class for IO operations with raw bytes. Objects of this class, for example, are used as data buffers in reading and writing files. </p>

<h4 id="bytestream-constructor">ByteStream constructor</h4>

<div class="codehilite"><pre><span></span><code><span class="nv">ByteStream</span><span class="p">()</span>
</code></pre></div>

<p>ByteStream's constructor doesn't have parameters.</p>

<p><strong>Example:</strong></p>

<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">with </span><span class="nv">bs</span> <span class="nv">ByteStream</span><span class="p">()</span> 
    <span class="p">(</span><span class="nf">to-bytes</span> <span class="nv">to</span><span class="o">:</span> <span class="nv">bs</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">textout</span> <span class="p">(</span><span class="nf">str</span> <span class="nv">ss</span><span class="p">)))</span> <span class="c1">// &lt;= [0, 0, 0, 1]</span>
</code></pre></div>

<h4 id="bytestream-methods">ByteStream methods</h4>

<hr />

<h3 id="filestream">FileStream</h3>

<p><code>FileStream</code> is a class through which in Transd file operations are performed.</p>

<h4 id="filestream-constructor">FileStream constructor</h4>

<div class="codehilite"><pre><span></span><code><span class="nv">FileStream</span><span class="p">()</span>
</code></pre></div>

<p>FileStream's constructor doesn't have parameters.</p>

<p><strong>Example:</strong></p>

<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">with </span><span class="nv">fs</span> <span class="nv">FileStream</span><span class="p">()</span> 
    <span class="p">(</span><span class="nf">open-r</span> <span class="nv">fs</span> <span class="nv">@sourceFile</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">textout</span> <span class="p">(</span><span class="nf">read-text</span> <span class="nv">fs</span><span class="p">)))</span>
</code></pre></div>

<h4 id="filestream-methods">FileStream methods</h4>

<hr />

<h2 id="built-in-functions">Built-in functions</h2>

<h6 id="textout">textout</h6>

<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nf">textout</span> <span class="p">[</span><span class="nv">to</span><span class="o">:</span> <span class="o">&lt;</span><span class="nv">streamObj</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">[</span><span class="nv">param</span><span class="p">]</span> <span class="o">...</span><span class="p">)</span>
</code></pre></div>

<p>Parameters:<br>
<em>streamObj : Stream</em> - (default: <code>StdOut</code>) a Stream object.<br>
<em>param</em> - a variable, literal or expression.</p>

<p>Return type: <code>Null</code></p>

<p>Prints out the parameters <code>[param]*</code> to a stream destination: <em>streamObj</em>. The destination can be of type <code>StringStream</code>, <code>ByteStream</code>, or <code>FileStream</code>. If the destination is not specified, the output is done to <code>StdOut</code>.</p>

<p><code>[param] ...</code> is a list of any number of space separated parameters. A parameter is any expression whose value can be represented by a text string. 'Null' values are represented by a null string and not printed.</p>

<p>Examples:</p>

<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">with </span><span class="nv">s</span> <span class="s">&quot;abcde&quot;</span>
    <span class="p">(</span><span class="nf">textout</span> <span class="p">(</span><span class="nf">front</span> <span class="nv">s</span><span class="p">)</span> <span class="p">(</span><span class="nf">back</span> <span class="nv">s</span><span class="p">)</span> <span class="p">(</span><span class="nf">clear</span> <span class="nv">s</span><span class="p">)</span> <span class="s">&quot; &quot;</span>
         <span class="p">(</span><span class="nf">eval</span> <span class="s">&quot;(front s)&quot;</span><span class="p">)</span> <span class="s">&quot; &quot;</span> <span class="p">(</span><span class="nf">eval</span> <span class="s">&quot;(back s)&quot;</span><span class="p">))</span>
<span class="p">)</span>
<span class="c1">// Output: ae false false</span>

<span class="p">(</span><span class="k">with </span><span class="nv">s</span> <span class="s">&quot;abcde&quot;</span> <span class="nv">n</span> <span class="mi">10</span>
    <span class="p">(</span><span class="nf">textout</span> <span class="s">&quot;The length of \&quot;&quot;</span> <span class="nv">s</span> <span class="s">&quot;\&quot; is &quot;</span> 
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="o">&gt;</span> <span class="p">(</span><span class="nf">size</span> <span class="nv">s</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span> <span class="s">&quot;more&quot;</span> <span class="k">else </span><span class="s">&quot;less&quot;</span><span class="p">)</span> <span class="s">&quot; than &quot;</span> <span class="nv">n</span> <span class="s">&quot; characters&quot;</span><span class="p">)</span>
<span class="p">)</span>
<span class="c1">// Output: The length of &quot;abcde&quot; is less than 10 characters.</span>
</code></pre></div>

<h2 id="built-in-classes">Built-in classes</h2>

<h3 id="directory">Directory</h3>

<h4 id="methods">Methods</h4>

<h6 id="read">read</h6>

<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nf">read</span> <span class="nv">subj</span> <span class="nv">dir</span> <span class="nv">filePatt</span><span class="p">)</span>
</code></pre></div>

<p>Parameters:<br>
<em>dir</em> : <code>String</code> - the directory whose contents are to be read;<br>
<em>filePatt</em> : <code>String</code> - the regular expression with the pattern of file names to include.<br>
Return type: <code>Null</code></p>

<p>Reads the contents of a directory <em>dir</em> by enumerating file and directory names, contained in it, and storing them in the internal list. After that, file and directory names can be retrieved with the methods <code>(files)</code> and <code>(dirs)</code> respectively.</p>

<h6 id="read-rec">read-rec</h6>

<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nf">read-rec</span> <span class="nv">subj</span> <span class="nv">rootDir</span> <span class="nv">filePatt</span><span class="p">)</span>
</code></pre></div>

<p>Parameters:<br>
<em>rootDir</em> : <code>String</code> - the directory whose contents are to be read;<br>
<em>filePatt</em>: <code>String</code> - the regular expression with the pattern of file names to include.<br>
Return type: <code>Null</code></p>

<p>Recursively reads file and directory names in a directory tree. After that, file and directory names can be retrieved with the methods <code>(files)</code> and <code>(dirs)</code> respectively.</p>


<hr width="100%" style="margin:30px 0 0 0;">
</div>
<div id="footer">
  <p>&copy; Copyright 2021-2022 <a href='&#109;ail&#116;o&#58;alb%65rger&#64;g%6Dai&#108;&#46;&#37;63o&#109;'>Albert Berger</a> &middot; All Rights Reserved</p>
</div>
</body>
</html>
