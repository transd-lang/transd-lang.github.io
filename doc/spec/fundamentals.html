<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>Fundamental concepts</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'>&lt;&lt; <a href="intro.html">Back</a> | <a href="index.html">Contents</a> | <a href="lexical.html">Forward</a> &gt;&gt;<br /><br /><h2>Fundamental concepts</h2><br /><br /><h3>Core syntax</h3><br /><br />The original idea from which the development of Transd has started was to extend the capabilities of application configuration files, so that the user could define in them not only data, but also had a flexible and rich means to define and extend the functionality of the application. Because of this, Transd is, probably, the first language whose program texts on top level are, basically, lists of name/value pairs:<br /><br /><div class="codebox"><div class="codebox">mainModule:&nbsp;<span style="color:#000000;font-weight:400">{</span><br /><br />	a&nbsp;:&nbsp;“Hello,&nbsp;”,<br /><br />	b&nbsp;:&nbsp;“world!”,<br /><br />	_start&nbsp;:&nbsp;(lambda&nbsp;(textout&nbsp;a&nbsp;b))<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />Transd syntax in a nutshell can be described as consisting of two levels.  The top level is strongly object-oriented, and the whole program is essentially a set of definitions of modules and classes. These definitions are given in a very regular way: as a sequence of assignment statements, which are arranged in  the form of name/value pairs.<br /><br />The definitions of modules&#39; and classes&#39; methods make up the bottom level of syntax. This level has a flavor of functional programming <em>“in which function definitions are trees of expressions that each return a value, rather than a sequence of imperative statements”</em> (Wikipedia). Although Transd is not a functional language, and may be used in a very state-dependent manner, it offers some features, however, that may emulate the functional programming style.<br /><br /><h3>Basic program structure</h3><br /><br />A Transd program on its top level consists of one or more modules and zero or more classes. The <em>class</em> notion in Transd has the usual semantics of a “template for creating objects”. <em>Modules</em> can be considered as singleton classes (classes with one and only one instantiated object). <br /><br /><div class="codebox"><div class="codebox">program&nbsp;:=&nbsp;{module_1&nbsp;[,(module_i&nbsp;|&nbsp;class_j)]*}<br /><br />module,&nbsp;class&nbsp;:=&nbsp;[access_modifier]&nbsp;(&nbsp;[&#39;module&#39;]&nbsp;|&nbsp;‘class’&nbsp;)&nbsp;&lt;name&gt;&nbsp;‘:&nbsp;{’&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;(&nbsp;name&nbsp;‘:’&nbsp;(&nbsp;data&nbsp;|&nbsp;lambda&nbsp;)&nbsp;‘,’&nbsp;)+&nbsp;}&nbsp;‘}’</div></div><br /><br />This BNF grammar shows that inside modules and classes all code is organized in the form of declarations and definitions of class members (methods and data fields).<br /><br /><div class="codebox"><div class="codebox">#lang&nbsp;transd<br /><br />class&nbsp;PT2&nbsp;:&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:&nbsp;Double(),<br />&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;:&nbsp;Double(),<br />&nbsp;&nbsp;&nbsp;&nbsp;init:&nbsp;(λ&nbsp;x_&nbsp;Double()&nbsp;y_&nbsp;Double()&nbsp;(set&nbsp;x&nbsp;x_)&nbsp;(set&nbsp;y&nbsp;y_)),<br />&nbsp;&nbsp;&nbsp;&nbsp;dist:&nbsp;(λ&nbsp;pt&nbsp;PT2()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sqrt&nbsp;(+&nbsp;(pow&nbsp;(-&nbsp;x&nbsp;pt.x)&nbsp;2&nbsp;)&nbsp;(pow&nbsp;(-&nbsp;y&nbsp;pt.y)&nbsp;2&nbsp;)&nbsp;)&nbsp;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br />}<br /><br />mainModule:&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;import:&nbsp;&quot;PT2()&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;pt1:&nbsp;PT2(&nbsp;1.0&nbsp;2.0&nbsp;),<br />&nbsp;&nbsp;&nbsp;&nbsp;pt2:&nbsp;PT2(&nbsp;3.0&nbsp;4.0&nbsp;),<br />&nbsp;&nbsp;&nbsp;&nbsp;_start:&nbsp;(λ&nbsp;(textout&nbsp;(dist&nbsp;pt1&nbsp;pt2)))<br />}	</div></div><br /><br /><br /><h3>Data model</h3><br /><br />Transd has strong support of object-oriented programming paradigm. There are no global variables. All the program&#39;s data and functions are members of some module or class definition. All interconnections between classes and modules in a program are done via import system. Every class and module can restrict access to its members via permissions system.<br /><br />Data objects in Transd are accessed and manipulated via variables (object names), there is no access to raw machine memory. Variable in Transd is a permanent reference: it is initialized at the place of declaration and the whole lifetime remains referring to the same object.<br /><br />When a variable is on the left side of assignment operation, the value is copied to the object, which the variable is referring to:<br /><br /><div class="codebox"><div class="codebox">a&nbsp;:&nbsp;Int(&nbsp;2&nbsp;),<br />b&nbsp;:&nbsp;Int(&nbsp;5&nbsp;),<br /><span style="color:#000000;font-weight:400">(</span>=&nbsp;a&nbsp;b<span style="color:#000000;font-weight:400">)</span></div></div><br /><br />After the third line, the variable <code>‘a’</code> points to the same <code>Int</code> object that was allocated on the first line, and this object has the value 5.<br /><br />Arguments are passed to functions by reference. This relates to both compound and primitive types. Expressions in calls are evaluated from left to right and their results are also passed by reference. <br /><br />Once data objects went out of their scope, they are automatically garbage collected.<br /><br /><br /><h3>Execution model</h3><br /><br />When a Transd program is loaded, all the source files in the assembly are read, parsed and virtual compiled. After that it&#39;s virtual compiled image is kept in memory and public functions of modules can be called for execution as many times as needed. <br /><br />If the entry point function is specified in the assembly description (manifest) file, or if the assembly contains a module called <code>‘mainModule’</code> with <code>‘_start’</code> member function, then this function is called automatically once the program is compiled.<br /><br /><br /><h3>Types and values</h3><br /><br />Transd is strongly and statically typed with occasional type inference. Every variable and expression has a type, which it receives at the place of the first appearance in the program text. This type either is declared explicitly or must be inferable from the context. The type of a variable, once declared, cannot be changed. <br /><br />Example: the following two variable declarations are equivalent:<br /><br /><div class="codebox"><div class="codebox">a&nbsp;:&nbsp;“Hello,&nbsp;”<br /><br />a&nbsp;:&nbsp;String<span style="color:#000000;font-weight:400">(</span>&quot;Hello,&nbsp;&quot;<span style="color:#000000;font-weight:400">)</span></div></div><br />	<br />Transd has a set of builtin types some of which are primitive, or basic, and others are compound. The basic types are: <br /><br /><code>Null, Bool, Int, Double, String, Vector, Index.</code><br /><br />The compound types include <code>Range, File, Directory</code>, etc.<br /><br />With the help of classes the user can define custom types which behave just as built-in ones.</div></body></html>